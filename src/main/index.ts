import { app, BrowserWindow, ipcMain, dialog } from 'electron'; // Uncomment ipcMain and dialog
import path from 'path'; // Uncomment path
import RecordingService from './services/RecordingService';
import { protocol } from 'electron';
import { ImageService } from './services/ImageService';
import ProjectService from './services/ProjectService';
import { IpcChannels } from '../shared/constants';
import ExportService, { ExportOptions } from './services/ExportService';
import { Tutorial, Step } from '../shared/types';
import fs from 'fs';
import { DbConnectionManager } from './services/DbConnectionManager';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string; // Use the correct preload entry constant

let mainWindow: BrowserWindow | null = null;
let recordingServiceInstance: RecordingService | null = null;
let projectServiceInstance: ProjectService | null = null;
let exportServiceInstance: ExportService | null = null;

// Register protocol handler for loading local files
function registerProtocolHandler() {
  protocol.registerFileProtocol('local-file', (request, callback) => {
    const url = request.url.replace('local-file://', '');
    try {
      const decodedUrl = decodeURIComponent(url);
      callback({ path: decodedUrl });
    } catch (error) {
      console.error('Failed to register protocol', error);
    }
  });
}

function createWindow() {
  // Log the preload path before creating the window
  console.log('MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY:', MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      // Use the correct Webpack entry for the preload script
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webSecurity: false, // Disable web security to allow loading local files
      spellcheck: false, // Disable spellcheck which can interfere with input fields
      enableWebSQL: true // Enable WebSQL for better compatibility
    }
  });

  // Listen for keyboard events in the main process
  mainWindow.webContents.on('before-input-event', (event, input) => {
    // Prevent Enter key from being processed by the window when recording is active
    if (input.key === 'Enter' && recordingServiceInstance?.getIsRecording) {
      console.log('[MainWindow] Intercepted Enter key in before-input-event');
      // Mark as handled to prevent it from being processed by the renderer
      event.preventDefault();
    }
  });

  // Set Content Security Policy
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    // Temporarily allow unsafe-eval for Webpack dev server compatibility
    // TODO: Refine CSP for production builds
    const scriptSrc = "'self' 'unsafe-inline' 'unsafe-eval'"; // Keep unsafe-eval for dev HMR

    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [`default-src 'self'; script-src ${scriptSrc}; style-src 'self' 'unsafe-inline'; img-src 'self' file: data: blob: filesystem:; connect-src 'self' ws: file:; media-src 'self' file:;`]
      }
    });
  });

  // Load the index.html of the app using the correct Webpack entry URL.
  console.log('Loading Webpack entry:', MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch(err => {
    console.error('Failed to load window:', err);
  });

  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
    // Wait for window to be ready before showing
    mainWindow.once('ready-to-show', () => {
      // Add null check before showing
      if (mainWindow) {
        mainWindow.show();
      }
    });
  }

  // Instantiate RecordingService *after* mainWindow is created
  // and pass the non-null mainWindow instance
  recordingServiceInstance = new RecordingService(mainWindow);
  // Initialize ProjectService
  projectServiceInstance = ProjectService.getInstance();
  // Initialize ExportService
  exportServiceInstance = ExportService.getInstance();
  
  // Call registerShortcuts here if needed on window creation
  // recordingServiceInstance.registerShortcuts(); 

  mainWindow.on('closed', () => {
    mainWindow = null;
    // Optionally nullify recordingServiceInstance too if needed
  });
}

function registerIpcHandlers() {
  // Register image loading handler
  ipcMain.handle(IpcChannels.LOAD_IMAGE_AS_DATA_URL, async (_event, imagePath) => {
    console.log(`Attempting to load image as data URL: ${imagePath}`);
    return await ImageService.imagePathToDataUrl(imagePath);
  });

  // Register shapes JSON loading handler
  ipcMain.handle(IpcChannels.LOAD_SHAPES_FROM_JSON, async (_event, imagePath) => {
    try {
      console.log(`[ShapesLoader] Loading shapes from JSON for image: ${imagePath}`);
      const jsonPath = `${imagePath}.shapes.json`;
      
      // Check if the shapes JSON file exists
      if (!fs.existsSync(jsonPath)) {
        console.log(`[ShapesLoader] No shapes JSON file found at: ${jsonPath}`);
        return [];
      }
      
      // Read the shapes JSON file
      const shapesJson = await fs.promises.readFile(jsonPath, 'utf8');
      const shapes = JSON.parse(shapesJson);
      console.log(`[ShapesLoader] Loaded ${shapes.length} shapes from JSON`);
      return shapes;
    } catch (error) {
      console.error('[ShapesLoader] Error loading shapes from JSON:', error);
      return [];
    }
  });

  // Register file dialog handler
  ipcMain.handle(IpcChannels.OPEN_FILE_DIALOG, async (_event, options) => {
    try {
      console.log(`[FileService] Opening file dialog with options:`, options);
      const result = await dialog.showOpenDialog(mainWindow!, options);
      return result;
    } catch (error) {
      console.error('[FileService] Error opening file dialog:', error);
      return { canceled: true, filePaths: [] };
    }
  });

  // Register image copy handler
  ipcMain.handle(IpcChannels.COPY_IMAGE_FILE, async (_event, options) => {
    try {
      console.log(`[ImageService] Copying image file:`, options);
      return await ImageService.copyImageFile(options);
    } catch (error) {
      console.error('[ImageService] Error copying image file:', error);
      return '';
    }
  });

  // Register data URL to temp file handler
  ipcMain.handle(IpcChannels.SAVE_DATA_URL_TO_TEMP_FILE, async (_event, options) => {
    try {
      console.log(`[ImageService] Saving data URL to temp file`);
      return await ImageService.saveDataUrlToTempFile(options);
    } catch (error) {
      console.error('[ImageService] Error saving data URL to temp file:', error);
      return '';
    }
  });

  // Register existing step management handlers
  ipcMain.handle(IpcChannels.GET_STEPS, async () => {
    return recordingServiceInstance?.getSteps() || [];
  });
  
  ipcMain.on(IpcChannels.ADD_STEP, (_event, step) => {
    recordingServiceInstance?.addStep(step);
  });
  
  // Export handlers
  ipcMain.handle(IpcChannels.EXPORT_TUTORIAL, async (_event, tutorialId: string, options: ExportOptions) => {
    try {
      console.log(`[ExportService] Exporting tutorial ${tutorialId} as ${options.exportFormat}`);
      if (!exportServiceInstance) {
        exportServiceInstance = ExportService.getInstance();
      }
      
      // Get tutorial details from database
      const databaseService = await projectServiceInstance?.getDatabaseService();
      if (!databaseService) {
        throw new Error('Database service not available');
      }
      
      const tutorial = await databaseService.getTutorial(tutorialId);
      if (!tutorial) {
        throw new Error(`Tutorial with ID ${tutorialId} not found`);
      }
      
      // Get steps for the tutorial
      const steps = await databaseService.getStepsByTutorial(tutorialId);
      if (!steps || steps.length === 0) {
        throw new Error('No steps found for this tutorial');
      }
      
      // Ensure user's Documents folder is accessible for exports
      const documentsDir = app.getPath('documents');
      const testPath = path.join(documentsDir, '.openscribe_test');
      
      try {
        // Test if we can write to the documents folder
        fs.writeFileSync(testPath, 'test');
        fs.unlinkSync(testPath); // Clean up test file
      } catch (fsError) {
        console.error('[ExportService] Cannot write to documents folder:', fsError);
        // If Documents isn't writable, try userData folder instead
        console.log('[ExportService] Falling back to userData directory for exports');
      }
      
      // Export the tutorial - ensure the tutorial ID is defined
      const tutorialData: Tutorial = {
        ...tutorial,
        id: tutorial.id || tutorialId // Ensure ID is defined
      };
      
      const filePath = await exportServiceInstance.exportTutorial(tutorialData, steps as Step[], options);
      console.log(`[ExportService] Tutorial exported successfully to: ${filePath}`);
      return filePath;
    } catch (error) {
      console.error('[ExportService] Error exporting tutorial:', error);
      
      // Provide more specific error messages for common issues
      if (error instanceof Error) {
        if (error.message.includes('ENOENT')) {
          throw new Error('File system error: Could not create or access the export file. Please check if the directory exists and you have write permissions.');
        } else if (error.message.includes('EACCES') || error.message.includes('permission denied')) {
          throw new Error('Permission denied: You do not have permission to write to the selected location. Please choose a different location.');
        } else if (error.message.includes('EPERM')) {
          throw new Error('Permission error: The operation was not permitted. Try running the application with admin privileges.');
        }
        throw error;
      }
      throw new Error('An unexpected error occurred during export. Please try again.');
    }
  });
  
  // Update tutorial status
  ipcMain.handle(IpcChannels.UPDATE_TUTORIAL_STATUS, async (_event, tutorialId: string, status: 'draft' | 'ready' | 'exported') => {
    try {
      console.log(`[TutorialService] Updating tutorial ${tutorialId} status to ${status}`);
      const databaseService = await projectServiceInstance?.getDatabaseService();
      if (!databaseService) {
        throw new Error('Database service not available');
      }
      
      const tutorial = await databaseService.getTutorial(tutorialId);
      if (!tutorial) {
        throw new Error(`Tutorial with ID ${tutorialId} not found`);
      }
      
      // Update the tutorial status
      const updatedData = {
        ...tutorial,
        status,
        updatedAt: new Date().toISOString()
      };
      
      // Save the updated tutorial using the correct method
      return await databaseService.updateTutorial(updatedData);
    } catch (error) {
      console.error('[TutorialService] Error updating tutorial status:', error);
      throw error;
    }
  });
  
  // Project handlers are registered inside ProjectService
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(async () => {
  registerProtocolHandler(); // Register custom protocol handler
  
  // Initialize services first
  if (!projectServiceInstance) {
    projectServiceInstance = ProjectService.getInstance();
  }
  
  // Verify shapes table exists
  try {
    console.log('[Main] Checking shapes table...');
    const dbManager = DbConnectionManager.getInstance();
    await dbManager.checkShapesTable();
    console.log('[Main] Shapes table verified.');
  } catch (error) {
    console.error('[Main] Error checking shapes table:', error);
  }
  
  // Create window (which initializes recording service)
  createWindow();
  
  // Register IPC handlers
  registerIpcHandlers();
  
  app.on('activate', () => {
    // On macOS it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and require them here.

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line @typescript-eslint/no-var-requires
if (require('electron-squirrel-startup')) {
  // ... rest of file ...
} 