# OpenScribe Problem Log

## Current Challenges

### Recording Engine
- **Global Input Hooks:** Switched from `global-mouse-events` (which failed to deliver events despite apparent successful initialization) to `uiohook-napi` for capturing mouse clicks. Need to verify `uiohook-napi` reliability and integrate the UI checkbox state.
- Need to investigate optimal screenshot capture frequency without impacting system performance
- Multi-monitor support might require additional testing and edge case handling
- Memory management during long recording sessions needs careful consideration
- **Multiple Step Creation On Single Click:** Fixed an issue where a single click would create multiple step entries (approximately 4 per click). Implemented debouncing with a 1-second threshold to prevent duplicate steps from being created in quick succession. This ensures that only one step is captured per user interaction.

### React Component Issues
- **Tab State Loss During Switching:** Fixed an issue where switching between tabs (Record, Edit Steps, Export) would cause the tabs to lose their state. Implemented a tabsState object in App.tsx that properly preserves each tab's state and visibility, allowing users to start recording, switch tabs, and then return to continue or stop recording without losing context.
- **Duplicate React Keys:** Fixed React warning about duplicate keys in the steps list. The original ID generation method using timestamp+number was causing collisions. Implemented a more robust unique ID generation approach using timestamp plus a random string, and added duplicate checking in the Zustand store to prevent duplicate entries.

### Build/Configuration Issues (Electron Forge + Webpack)
- **Persistent Preload Script Load Failure:** Despite various configuration attempts (manual path calculation, Forge magic variables, explicit Webpack output settings, simplified source file), the preload script (`src/preload.ts`) is consistently failing to be built and/or loaded correctly during `electron-forge start`. The main process cannot find the expected compiled file (`.webpack/preload/main_preload.js`), resulting in an ENOENT error. The `MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY` variable also points to an incorrect location.
- **~~Persistent~~ Tailwind CSS Styling Failure (Likely Resolved):** Tailwind styles ~~are not~~ were previously not being applied in the renderer process during development (`electron-forge start`). ~~Basic CSS loading works, but including `postcss-loader` (with correct config for `@tailwindcss/postcss` and `autoprefixer`) results in unstyled components. Network tab shows no CSS loaded.~~ This seems to have been caused by caching issues within Electron Forge or Webpack's development server. Deleting the `.webpack` directory and restarting the development server (`npm start`) resolved the immediate problem. Further monitoring is needed to ensure it doesn't recur.

### Performance Concerns
- Large number of screenshots might cause memory issues
- Need to determine best storage strategy for temporary files
- Image optimization vs quality trade-offs need to be balanced
- Project list might become unwieldy if many projects are saved - may need pagination or better organization

### Cross-Platform Compatibility
- iohook event handling might vary across different Windows versions
- Screen capture APIs might behave differently on various hardware configurations
- File paths for project storage need to be tested across platforms

## Resolved Issues
- **Multiple Step Creation:** Fixed by implementing debouncing in the RecordingService mouseUpHandler
- **Tab State Persistence:** Fixed by updating App component to maintain independent tab states
- **Duplicate React Keys:** Fixed by implementing more robust unique ID generation
- **Project Management:** Implemented ability to create, save, and load projects via sidebar

## Investigation Needed
1. Best practices for handling system-wide keyboard hooks
2. Optimal image compression strategy for different types of screenshots
3. Most efficient IPC patterns for main/renderer process communication
4. Auto-update mechanism security considerations

## Notes
- Regular performance profiling will be needed
- Consider implementing detailed logging for debugging
- Plan for automated stress testing

# Problem Log

This file tracks persistent issues encountered during development that require further investigation or have proven difficult to resolve.

*   **Date:** 2024-04-27
    *   **Problem:** Multiple steps created on single click and tab state not persisting when switching tabs
    *   **Context:** Clicking during recording would add approximately 4 steps instead of 1, and switching between tabs would cause the recording state to be lost
    *   **Difficulty:** The issue was likely caused by multiple uIOhook events firing for a single click and the lack of proper tab state persistence in the React component architecture
    *   **Status:** Resolved - Added debouncing to click handling in RecordingService and implemented tab state persistence in App.tsx

*   **Date:** 2024-04-27
    *   **Problem:** React warning about duplicate keys in steps list
    *   **Context:** Console showing errors when steps are created: "Encountered two children with the same key"
    *   **Difficulty:** The timestamp + step number approach for ID generation was creating collisions due to rapid step creation and multiple tabs rendering the same steps
    *   **Status:** Resolved - Implemented more robust unique ID generation with timestamp + random string, and added duplicate checking in the store

*   **Date:** 2025-05-05
    *   **Problem:** Screenshots not displaying in the Edit Steps section
    *   **Context:** Local screenshots were being captured and saved correctly, but wouldn't display in the UI due to Electron's security restrictions for file:// protocol
    *   **Difficulty:** Electron's default security settings prevent loading local resources via file:// protocol and the Content Security Policy was blocking access
    *   **Status:** Resolved - Implemented a comprehensive solution after trying multiple approaches:
        1) First attempt: Modified BrowserWindow creation to set webSecurity: false and updated Content-Security-Policy
        2) Second attempt: Created custom 'local-file://' protocol handler 
        3) Final working solution: Created an ImageService to read image files and convert them to base64 data URLs
           - Added an IPC handler in the main process to load images as data URLs
           - Added image caching in the renderer to optimize performance
           - Implemented a loading state indicator while images are loading

*   **Date:** 2024-05-12
    *   **Problem:** Screenshot display was too large in the Edit Steps section and lacked interaction options
    *   **Context:** Large screenshots took up too much space in the UI, making it difficult to view multiple steps efficiently
    *   **Difficulty:** Needed to balance between showing enough information for step recognition while not overwhelming the UI
    *   **Status:** Resolved - Implemented the following improvements:
        1) Reduced screenshot display size to 50% width to make better use of screen space
        2) Added a click-to-enlarge functionality with a modal overlay to view full-size screenshots when needed
        3) Added a visual indicator ("Click to enlarge") to make the functionality discoverable

*   **Date:** 2024-07-12
    *   **Problem:** Project creation failing due to missing database methods
    *   **Context:** Clicking the "Create Project" button resulted in errors in the console: "TypeError: this.databaseService.createProject is not a function"
    *   **Difficulty:** The DatabaseService class was missing implementation for several critical methods: createProject, getAllProjects, and getRecentTutorials
    *   **Status:** Resolved - Added implementations for the missing methods in DatabaseService:
        1) Implemented createProject method to handle project creation and ID generation
        2) Implemented getAllProjects method to retrieve all projects from the database
        3) Implemented getRecentTutorials method to get recently updated tutorials
        4) Fixed database access by adding direct DbConnectionManager instance to DatabaseService

*   **Date:** 2024-07-13
    *   **Problem:** Database schema mismatch causing project creation to fail
    *   **Context:** Creating a new project fails with error "table projects has no column named tags" despite the column being defined in the schema
    *   **Difficulty:** The database schema definition in code includes a 'tags' column but the actual database doesn't have this column, suggesting a migration issue or database recreation problem
    *   **Status:** Resolved - Modified the createProject and getAllProjects methods to work with the existing database schema by removing references to the non-existent tags column. A proper fix would involve either:
        1) Adding the missing column via an ALTER TABLE statement 
        2) Ensuring the schema definition matches the actual database by validating schema during startup
        3) Implementing proper database migrations to handle schema changes

*   **Date:** 2024-07-13
    *   **Problem:** Missing database methods causing cascade of functionality failures
    *   **Context:** After fixing project creation, other operations were failing with errors like "getProject is not a function" and "createTutorial is not a function"
    *   **Difficulty:** The database service was missing several essential methods needed for proper application functioning
    *   **Status:** Resolved - Implemented the following missing methods:
        1) getProject - To retrieve project details by ID
        2) createTutorial - To create new tutorials for a project
        3) getTutorialsByProject - To list tutorials belonging to a specific project
        This reveals a systematic issue with the application where database methods were referenced before being fully implemented.

*   **Date:** 2024-07-13
    *   **Problem:** Missing getTutorial method causing "Tutorial not found" errors
    *   **Context:** After implementing project creation and createTutorial, the app couldn't find tutorials due to missing database method
    *   **Difficulty:** The pattern of missing essential database methods continues to cause cascading failures throughout the application
    *   **Status:** Resolved - Implemented the getTutorial method to retrieve tutorial details by ID, addressing the "Error: Tutorial not found" popup and the TypeError for this.databaseService.getTutorial

*   **Date:** 2024-07-13
    *   **Problem:** Steps disappearing when returning to a tutorial and duplicate step entry notifications
    *   **Context:** 
        1) When navigating away from a tutorial and coming back, the steps weren't visible
        2) Console shows multiple "Step with ID ... already exists, skipping addition" messages
    *   **Difficulty:** Multiple issues occurring together:
        1) Both ProjectService and TutorialService were registering handlers for the same IPC channels (e.g., GET_STEPS_BY_TUTORIAL)
        2) Missing deleteTutorial and deleteProject methods in DatabaseService
        3) Service architecture causing duplicate attempts to add the same steps
    *   **Status:** Resolved - Implemented the following fixes:
        1) Added the missing deleteTutorial and deleteProject methods to DatabaseService
        2) Fixed the StepsTab component to properly clear and reload steps when navigating to a tutorial
        3) Removed duplicate IPC handler in TutorialService for GET_STEPS_BY_TUTORIAL
        4) Added additional logging to help debug step loading issues
        5) Improved the loadStepsForTutorial function to better handle state management

*   **Date:** 2024-07-13
    *   **Problem:** Steps not visible after switching between pages even after previous fixes
    *   **Context:** 
        1) Steps were still not showing up in the UI even after returning to a tutorial
        2) Console logs showed steps were being detected but not displayed
    *   **Difficulty:** Issues with component rendering and state management:
        1) Steps were being loaded but the UI wasn't displaying loading states properly
        2) StepRepository was not providing enough diagnostic information to debug database issues
        3) Multiple state management problems in the StepsTab component
    *   **Status:** Resolved - Implemented the following fixes:
        1) Enhanced StepRepository with better logging to detect if steps are actually being retrieved
        2) Added proper loading states to StepsStore with isLoading flag
        3) Added explicit "No steps found" message when a tutorial has no steps
        4) Fixed StepsTab component to properly use Zustand store methods for clearSteps
        5) Added more helpful error states and loading indicators

*   **Date:** 2024-07-13
    *   **Problem:** Steps not being saved to the database during recording
    *   **Context:** 
        1) Recording worked, but steps were never persisted to the database
        2) When returning to a tutorial, the steps array showed 0 items
        3) Multiple duplicate step creation notifications in the console
    *   **Difficulty:** Multiple architectural issues:
        1) RecordingTab component was missing proper step saving functionality
        2) Step creation event handler was defined incorrectly
        3) React component lifecycle issues where listener mounted multiple times
        4) Steps were added to Zustand store but never persisted to the database
    *   **Status:** Resolved - Implemented the following fixes:
        1) Properly implemented step saving in RecordingTab to ensure steps are saved to database
        2) Fixed dependency array issues in useEffect to prevent multiple event listeners
        3) Enhanced StepsTab with better error handling and debug logging
        4) Added fail-safe mechanism to force refresh steps when store is empty but steps exist
        5) Improved type safety in components to prevent undefined values

*   **Date:** 2024-08-05
    *   **Problem:** Steps recorded in one tutorial were being saved to all tutorials in the same project
    *   **Context:** 
        1) When recording steps in one tutorial within a project, the steps would appear in all tutorials belonging to that project
        2) This made it impossible to have multiple distinct tutorials with different steps within the same project
    *   **Difficulty:** Multiple architectural issues found:
        1) Both ProjectService and TutorialService had duplicate IPC handlers for step operations
        2) In particular, both services registered handlers for SAVE_STEP, UPDATE_STEP, DELETE_STEP, and REORDER_STEPS
        3) The handlers would override each other, causing inconsistencies in which service handled the operation
        4) RecordingTab component was registering multiple step creation listeners that would save the same step to different tutorials
        5) Missing promise handling in saveStep method led to asynchronous race conditions
        6) Step tutorialId validation was missing, allowing steps to be saved to the wrong tutorial
    *   **Status:** Resolved - Implemented the following fixes:
        1) Commented out duplicate IPC handlers in TutorialService, keeping only those in ProjectService
        2) Added step deduplication in RecordingTab to prevent the same step from being saved multiple times
        3) Fixed the RecordingTab component to only save steps to the currently selected tutorial
        4) Added tutorialId validation in the ProjectService saveStep method to ensure steps are saved only to the current tutorial
        5) Properly implemented async/await pattern in database operations to prevent race conditions
        6) Added comprehensive logging throughout the step saving process for better debugging
        7) Added warning notice about MaxListenersExceededWarning that can be safely ignored

*   **Date:** 2024-08-13
    *   **Problem:** Export functionality failing with "File system error" when attempting to export tutorials
    *   **Context:** 
        1) Users would get "Export failed: Error invoking remote method 'tutorial:export': Error: ENOENT: no such file or directory" when trying to export tutorials
        2) The temporary file paths used in the export process were either invalid or the directories didn't exist
        3) The export would completely fail even though the PDF/DOCX generation code seemed valid
    *   **Difficulty:** Multiple issues with the export process:
        1) The PDF export was trying to use Helvetica font which wasn't correctly available in the packaged app
        2) The ExportService wasn't properly handling file path, permissions, and directory existence issues
        3) Error messages were too generic and didn't provide actionable information to users
        4) The temp directory for exports wasn't being created before attempting to write files
        5) No permission checking was occurring before attempting to write files
    *   **Status:** Resolved - Implemented the following fixes:
        1) Updated PDF export to use Times font family instead of Helvetica for better cross-platform support
        2) Added explicit error handling for common file system issues (ENOENT, EACCES, EPERM)
        3) Implemented directory and permissions verification before attempting to write files
        4) Added robust error handling during file creation with specific error messages
        5) Fixed the export dialog to properly handle file selection cancellation
        6) Added better error handling for image loading during export
        7) Enhanced error messages to provide users with actionable information

*   **Date:** 2024-09-15
    *   **Problem:** Steps not updating in real-time during recording
    *   **Context:** 
        1) When recording steps for a tutorial, the steps weren't visible in the Edit Steps tab until switching off the page and coming back
        2) This created a poor user experience where users couldn't see their recording progress in real-time
    *   **Difficulty:** Multiple UI state synchronization issues:
        1) The RecordingTab was saving steps correctly but not updating the UI appropriately
        2) The StepsTab component wasn't receiving notifications about newly created steps
        3) No shared state mechanism between tabs to ensure consistent data
    *   **Status:** Resolved - Implemented the following fixes:
        1) Enhanced RecordingTab to update state immediately after saving steps and to notify other components
        2) Added a step notification channel using IPC to broadcast step updates across the application
        3) Improved StepsTab to listen for step updates in real-time
        4) Added shared state in the App component to ensure consistent step data between tabs
        5) Made the application properly refresh step displays without requiring tab switching

## 2025-05-05: SQLite Database Errors

### Issues Encountered:

1. **SQL Syntax Error with Reserved Keywords**: 
   - Error: `SQLITE_ERROR: near "order": syntax error`
   - Cause: Using the SQLite reserved keyword "order" as a column name without quoting it
   - Resolution: Added double quotes around "order" in all SQL statements (CREATE TABLE, CREATE INDEX, SELECT, UPDATE)

2. **Promise Handling in Database Methods**:
   - Error: `TypeError: projects.map is not a function`
   - Cause: The sqlite3 adapter returns Promises that were not being properly awaited
   - Resolution: Updated database methods to be async and properly await results

3. **Null/Undefined Results Handling**:
   - Error: Attempting to map over null or undefined database results
   - Resolution: Added null checks and default empty arrays to prevent errors

4. **Unique Constraint Violations During Migration**:
   - Error: `SQLITE_CONSTRAINT: UNIQUE constraint failed: projects.id`
   - Cause: Attempting to insert projects with IDs that already exist in the database
   - Resolution: Added checks to see if records exist before attempting to insert them

### Preventative Measures:

1. Always quote SQLite reserved keywords in SQL statements
2. Use proper async/await patterns when working with database operations
3. Add comprehensive error handling with try-catch blocks
4. Ensure null checking and provide default values for database results
5. Check for existing records before insertion to prevent constraint violations

## 2024-06-23: UI Enhancement - Project and Tutorial Deletion

### Implemented Features:

1. **Three-dot Menu for Projects and Tutorials**:
   - Added dropdown menus with delete options for both projects and tutorials
   - Implemented using React's useState to track active dropdowns
   - Added click-outside detection to close dropdowns when clicking elsewhere

2. **Deletion Confirmation and Handling**:
   - Added confirmation dialogs to prevent accidental deletion
   - Connected to existing electronAPI.deleteProject and electronAPI.deleteTutorial methods
   - Implemented immediate UI refresh after deletion to show current state

### Challenges Encountered:

1. **TypeScript Strict Type Checking**:
   - Error: Type errors related to potentially undefined IDs in project and tutorial objects
   - Resolution: Added comprehensive null/undefined checks for all project and tutorial IDs
   - Added fallback values for keys and defensive programming patterns to handle edge cases

2. **UI State Management**:
   - Challenge: Needed to ensure only one dropdown is open at a time and closes appropriately 
   - Solution: Implemented a single activeDropdown state variable and click-outside handler

### Preventative Measures:

1. Always include null/undefined checks for object properties, especially IDs
2. Use defensive programming when working with potentially undefined values
3. Provide fallback values for React keys to prevent rendering errors
4. Include proper error handling for all API calls with user feedback 

## 2024-06-26: Complete Database System Redesign

### Issues Encountered:

1. **Data Consistency Problems**:
   - Symptoms: Steps not saving reliably, unable to select tutorials, text fields not working
   - Cause: Multiple services handling the same database operations, leading to race conditions and synchronization issues
   - Root Problem: Both ProjectService and TutorialService had duplicate IPC handlers for steps operations

2. **Database Initialization Pattern**:
   - Issue: Database was attempting to force synchronous behavior with async code patterns
   - Problematic Code: Using setImmediate() to initialize database without properly awaiting completion
   - Impact: Operations could run before database was fully initialized, causing inconsistent behavior

3. **Improper Error Handling**:
   - Issue: Database operations lacked proper transaction management
   - Impact: Failed operations could leave database in inconsistent state
   - Example: Step creation lacking validation to ensure the referenced tutorial exists

4. **UI State Management**:
   - Issue: No reliable mechanism to refresh data when operations completed
   - Impact: UI would show stale data after operations completed elsewhere

### Redesign Solution:

1. **New Architecture**:
   - Implemented a proper separation of concerns:
     - DbConnectionManager: Handles connection lifecycle and transactions
     - BaseRepository: Provides common database operation patterns
     - Entity Repositories (e.g., StepRepository): Handle specific entity operations
     - DatabaseService: Coordinates between repositories and handles caching
     - Migration Services: Handle schema creation and data migration

2. **Improved Transaction Management**:
   - Added proper transaction support with rollback on errors
   - Implemented executeInTransaction helper method for standardized transaction handling
   - Added data validation before operations to prevent inconsistent data

3. **Robust Error Handling**:
   - Added comprehensive try/catch blocks for all database operations
   - Implemented detailed logging for all database operations
   - Added data validation checks to prevent invalid operations

4. **Client-Side Repositories**:
   - Added a client-side repository pattern for renderer process
   - Implemented caching to reduce IPC calls
   - Added data validation before sending to main process

### Preventative Measures:

1. Use proper asynchronous patterns with async/await consistently
2. Never attempt to force synchronous behavior with asynchronous code
3. Always use transactions for multi-step operations
4. Validate data integrity before database operations
5. Use a repository pattern to centralize database access
6. Implement proper error handling and logging
7. Use caching strategies to improve performance and reduce IPC calls

### Status: 
Implemented. The new database system should resolve issues with step saving, tutorial selection, and text input fields. 

## 2024-08-20: Missing Right-Side Recording Toolbar

### Issues Encountered:

1. **Missing Feature**:
   - Symptoms: Recording toolbar on the right side of the recording screen was missing
   - Impact: Users couldn't see or control capture mode, auto-capture on click, or auto-capture on enter options
   - User Workflow Disruption: No visual indicator of current capture settings during recording sessions

2. **UI Component Issue**:
   - Cause: The `RightSidebarContent` component was defined in App.tsx but not rendered in the UI
   - Context: This component contained important recording options including:
     - Capture mode dropdown (Full Screen)
     - Auto-capture on click toggle
     - Auto-capture on enter key toggle
     - Keyboard shortcuts reference

### Solution Implemented:

1. **UI Layout Updates**:
   - Modified the App.tsx component to conditionally render the right sidebar when the Record tab is active
   - Added proper flex layout structure to accommodate the sidebar without disrupting the main content
   - Set width to 64 (16rem) to provide sufficient space for options without overwhelming the UI

2. **Component Integration**:
   - Ensured the RecordingTab component receives and uses the auto-capture settings via props
   - Added state updates in RecordingTab to respond to changes in auto-capture settings
   - Updated status messages to reflect current auto-capture settings (click and/or enter key)

3. **State Synchronization**:
   - Implemented useEffect hooks to ensure RecordingTab component stays in sync with App settings
   - Added proper message handling to inform users of current recording settings

### Preventative Measures:

1. Document UI component relationships in STRUCTURE.md to prevent accidental omission of important UI elements
2. Always test all user-facing features after UI modifications
3. Consider implementing automated UI tests to ensure critical UI elements are present
4. Maintain a component inventory to track which components should be rendered in specific contexts

### Status: 
Implemented. Recording toolbar is now visible on the right side of the screen when the recording tab is active, allowing users to control capture settings.

## 2024-08-19
    *   **Problem:** Markup shape positioning issues when moving shapes
    *   **Context:** 
        1) When selecting and moving markup shapes (rectangles, ellipses, arrows), they would snap incorrectly to the left of the mouse cursor position
        2) This made precise positioning of markup elements difficult and frustrating for users
    *   **Difficulty:** Coordinate calculation issues:
        1) The code was incorrectly calculating the position during shape movement
        2) Scaling factors between original image and canvas were not being applied consistently
        3) The dragOffset calculation was not properly accounting for scaling
        4) Different shape types were handled inconsistently, creating different behavior for rectangles vs. ellipses
    *   **Status:** Resolved - Implemented the following fixes:
        1) Simplified the handleMouseDown and handleTouchStart functions to use a consistent approach for all shape types
        2) Standardized how dragOffset is calculated during initial selection
        3) Fixed coordinate transformation between canvas (display) and original image coordinates
        4) Updated the movement calculations in handleMouseMove and handleTouchMove to use proper scaling
        5) Consolidated the movement code for different shape types (rectangle, ellipse, line, arrow) to ensure consistent behavior
        6) Added proper conversions between canvas coordinates and original image coordinates

## 2024-09-03: Markup Shape Positioning Issues

### Issues Encountered:

1. **Markup Shape Display Inconsistency**:
   - Symptoms: Shapes drawn in MarkupModal appeared at incorrect positions when displayed in preview components
   - Impact: Users couldn't properly view their annotated screenshots in Steps and Export tabs
   - Root Cause: Coordinates for shapes were being saved relative to the scaled canvas in the markup modal instead of the original image dimensions

2. **Double Scaling Problem**:
   - Context: When displaying shapes in the preview, they were being scaled again based on already-scaled coordinates
   - Technical Details: Shapes were drawn in a canvas that might be smaller than the original image dimensions, creating a mismatch in coordinate systems
   - Additional Complexity: PreviewCanvas component was correctly scaling shapes based on its dimensions, but starting from the wrong coordinate system

### Solution Implemented:

1. **Coordinate System Normalization**:
   - Modified MarkupModal to store all shape coordinates relative to the original image dimensions
   - Added state tracking for original image dimensions and scale factors
   - Applied appropriate scaling when drawing shapes on the canvas in the modal

2. **Shape Coordinate Conversion**:
   - Added conversion functions to transform between:
     - Original image coordinates (stored in state)
     - Display coordinates (used for drawing on scaled canvas)
   - Updated mouse/touch event handlers to properly convert coordinates

3. **Preview Component Enhancement**:
   - Enhanced debugging in PreviewCanvas to log scaling factors and coordinates
   - Added UI feedback by showing the number of shapes on the markup button
   - Ensured consistent display across Steps tab and Export tab

4. **Code Cleanup**:
   - Removed unnecessary setTimeout for shape loading
   - Improved handling of shape selection and dragging

### Preventative Measures:

1. Always normalize coordinates to a consistent reference frame when working with canvas elements
2. Use separate data structures for storage (original coordinates) and display (scaled coordinates)
3. Add clear debugging logs for scaling operations
4. Be explicit about coordinate system transformations in comments

### Status: 
Implemented. Markup shapes now correctly appear in both the markup modal and preview components, allowing users to create and view annotations consistently.

## 2024-09-04: Markup Save Failure Issue

### Issues Encountered:

1. **Markup Save Error**:
   - Symptoms: "Failed to save markup. Step information not found" error when trying to save markup annotations
   - Impact: Users were unable to save markup annotations on screenshots
   - Root Cause: The StepRepository's getStepById method was failing to find steps when the currentTutorialId was not set

2. **Step Lookup Logic**:
   - Context: When opening the markup modal and trying to save shapes, the system couldn't locate the step information
   - Technical Details: The StepRepository initially only searched for steps within the currentTutorialId
   - Additional Complexity: When switching between tutorials or reloading the app, currentTutorialId was sometimes not set correctly

### Solution Implemented:

1. **Enhanced Step Lookup Logic**:
   - Modified StepRepository.getStepById to search more extensively:
     - First try to find the step in the current tutorial (if set)
     - If not found or no current tutorial, search all projects and tutorials
   - Added better logging to track step lookup process
   - Improved error handling to provide more meaningful error messages

2. **In-memory Step Handling in Markup Save Logic**:
   - Updated handleSaveMarkup to first check for steps in memory before querying database
   - Added detailed logging for markup save operations
   - Enhanced error handling to preserve unsaved work when errors occur

### Preventative Measures:

1. Implement enhanced step caching to reduce database queries
2. Add validation for step IDs and screenshot paths before attempting markup operations
3. Improve error messages to provide users with more helpful information
4. Maintain more consistent state between tabs to prevent loss of context

### Status: 
Implemented. Users can now save markup annotations on their screenshots without encountering step lookup errors.

## 2024-09-04: StepsTab UI Enhancement

### Issues Encountered:

1. **Poor Visual Hierarchy in StepsTab**:
   - Symptoms: Cluttered step editing interface with confusing layout and poor visual organization
   - Impact: Difficult user experience when creating and editing tutorial steps
   - Root Cause: Basic styling with minimal attention to visual design and usability

2. **Inconsistent UI Elements**:
   - Context: Different parts of the interface had inconsistent styling (buttons, cards, etc.)
   - Technical Details: Lacked proper component styling, spacing, and visual feedback for interactive elements
   - Additional Complexity: Unclear visual indicators for state (selected items, hover states, etc.)

### Solutions Implemented:

1. **Card-Based Layout**:
   - Created a card-based interface for the step editor with proper spacing, borders, and shadows
   - Added header and footer sections to organize content logically
   - Improved spacing and padding throughout the interface

2. **Improved Visual Feedback**:
   - Enhanced button styling with icons and hover states
   - Added visual indicators for selected steps
   - Implemented better empty states with helpful instructions
   - Added markup indicators to show when steps have annotations

3. **Responsive Layout Improvements**:
   - Maintained existing functionality while improving the visual design
   - Used aspect-ratio properties for screenshot containers to maintain consistent dimensions
   - Improved color scheme consistency throughout the interface

### Results:

The new UI provides better visual hierarchy, clearer interactions, and a more professional appearance while maintaining all existing functionality. Users can more easily identify selected steps and available actions.

## 2024-09-05: Markup Shape Resize Handle Fix

### Issues Encountered:

1. **Incorrect Shape Resize Behavior**:
   - Symptoms: When resizing markup shapes (especially rectangles), the corner would snap to the cursor position instead of scaling the shape properly
   - Impact: Users couldn't properly resize shapes as the resize operation was counter-intuitive
   - Root Cause: The code wasn't properly converting between canvas (display) coordinates and original image coordinates

2. **Inconsistent Behavior Across Shape Types**:
   - Context: Rectangle, ellipse, and line/arrow shapes had different resize behaviors
   - Technical Details: The resize handlers were not applying proper coordinate transformations consistently
   - Additional Complexity: Touch and mouse events had different handling logic

### Solution Implemented:

1. **Coordinate Transformation Fix**:
   - Added proper conversion from canvas coordinates to image coordinates during resize operations
   - Updated all resize handlers to use consistent coordinate conversion
   - Ensured both mouse and touch events handle resizing correctly

2. **Shape Type Consistency**:
   - Standardized the resize logic across all shape types (rectangle, ellipse, line/arrow)
   - Applied the same coordinate transformation approach to all shape types
   - Made sure the resize logic is consistent between mouse and touch events

### Results:

Users can now resize shapes naturally, with the shape scaling properly relative to mouse movement. The corner points of shapes no longer snap to the cursor position, making the markup experience much more intuitive and precise.

## 2024-09-04: Screenshot Scaling and Display Improvements

### Issues Encountered:

1. **Inconsistent Screenshot Display Sizes**:
   - Symptoms: Screenshots appeared too small in full-screen view and too large in windowed view
   - Impact: Users had difficulty viewing details in full-screen mode and screenshots dominated the UI in windowed mode
   - Root Cause: Fixed dimensions used for canvas elements without considering aspect ratio or viewport size

2. **Markup Shape Positioning Issues in Different Viewing Modes**:
   - Context: Markup shapes appeared in incorrect positions when switching between windowed and full-screen views
   - Technical Details: Shape coordinates were not scaled proportionally when the image size changed
   - Additional Complexity: Different coordinate systems were used in different views (canvas vs. original image)

### Solutions Implemented:

1. **Improved Image Scaling**:
   - Enhanced ImageModal to display images at 98% of viewport size in full-screen mode
   - Implemented aspect ratio preservation for screenshots in all viewing modes
   - Added proper padding and spacing to improve visual appearance

2. **Proportional Markup Scaling**:
   - Updated PreviewCanvas component to calculate and apply correct scaling for shapes
   - Implemented coordinate system normalization between original image and display size
   - Added intelligent scaling based on the actual rendered dimensions of images

3. **MarkupModal Enhancement**:
   - Improved canvas size calculation to better use available screen space
   - Implemented more robust image scaling with better aspect ratio preservation
   - Added error handling for image loading issues

### Results:

The screenshot display now provides consistent viewing experiences in both windowed and full-screen modes. Markup annotations are correctly positioned regardless of the viewing mode, and images maintain their aspect ratio while making better use of available screen space.

## 2024-09-04: UI Refinements - Markup Button

### Issues Encountered:

1. **Distracting Markup Shape Indicator**:
   - Symptoms: Green circle with shape count on the markup button was visually distracting
   - Impact: The indicator drew too much attention in the UI, creating visual noise
   - Resolution: Removed the shape count indicator while maintaining the markup functionality

### Solution Implemented:

1. **Cleaner Button Design**:
   - Modified the markup button to maintain its functionality but with a cleaner appearance
   - Removed the green circle with number that appeared when shapes were present
   - Maintained all shape tracking functionality for the markup feature

### Lessons Learned:
- Visual indicators should be used sparingly and only when they provide critical information
- Maintaining a clean, distraction-free UI often requires removing non-essential visual elements

## 2024-09-05: Shape Inversion Fix

### Issues Encountered:

1. **Rectangle Shape Inversion Problem**:
   - Symptoms: Shapes couldn't be properly inverted by dragging vertices past the opposite side
   - Impact: Users couldn't flip/invert shapes by pulling vertices through to the other side
   - Root Cause: The coordinate handling was confusing the vertices when attempting to drag past each other

2. **Vertex Control Behavior**:
   - Context: When users attempted to drag a vertex through the middle of the shape, the app would get confused
   - Technical Details: The previous implementation had issues when tracking which vertex was being manipulated
   - Additional Complexity: The behavior was inconsistent between mouse and touch events

### Solution Implemented:

1. **Direct Vertex Manipulation**:
   - Modified the resize logic to use a switch statement that explicitly handles each corner case
   - Implemented simple direct control of each vertex without normalization logic
   - Applied the same vertex-specific approach to all shape types for consistency
   
2. **Status**: Resolved
   - Users can now drag vertices through the opposite side to flip shapes both horizontally and vertically
   - The behavior is more intuitive and matches user expectations for shape manipulation

## 2024-09-06: Improved Shape Orientation Handling

### Issues Encountered:

1. **Markup Shape Flipping and Orientation Issues**:
   - Symptoms: After flipping shapes by dragging vertices through the opposite side, further manipulations would behave inconsistently
   - Impact: Users couldn't reliably manipulate shapes that had been previously flipped or inverted
   - Root Cause: The corner detection logic wasn't properly detecting which vertex was which after shape orientation changes

2. **Coordinate Tracking Problems**:
   - Context: When a shape was flipped or inverted, the start/end points would get confused
   - Technical Details: The code was using fixed start/end properties without considering the actual visual orientation of the shape
   - Additional Complexity: Needed to distinguish between "logical" start/end points in the data structure vs. "visual" corners in the UI

### Solution Implemented:

1. **Dynamic Corner Detection**:
   - Modified findShapeAtPoint function to calculate corners based on actual positions rather than stored start/end properties
   - Added explicit corner identification (nwCorner, neCorner, etc.) based on real coordinates
   - This ensures that corner detection remains consistent regardless of previous manipulations

2. **Orientation-Aware Resize Handling**:
   - Implemented comprehensive resize logic that evaluates the current shape orientation
   - Added tracking of relative positions (startIsLeftOfEnd, startIsAboveEnd) to determine the actual visual orientation
   - Created orientation-specific resize behavior that correctly handles all possible states (4 orientations × 4 corners)

### Results:

Users can now freely manipulate shapes regardless of previous flipping, rotation, or resizing operations. The markup tool maintains consistent behavior even after shapes have been inverted or flipped in any orientation.

*   **Date:** 2024-08-17
    *   **Problem:** Shape markups (annotations) not persisting between application restarts
    *   **Context:** 
        1) Users could draw shapes (rectangles, arrows, ellipses) on screenshots to annotate them
        2) These annotations were stored in memory via Zustand store but lost when the application was restarted
        3) The markup functionality worked well but lacked persistence
    *   **Difficulty:** Database infrastructure needed to be extended:
        1) No existing table structure for storing shape data in the database
        2) The client-side shape model needed to be matched in the database
        3) Repository methods needed to be implemented for CRUD operations
        4) Needed to add new IPC methods to communicate between renderer and main processes
    *   **Status:** Resolved - Implemented the following:
        1) Added a new 'shapes' table to the database schema with appropriate columns and indexes
        2) Created a ShapeRepository class for database operations on shapes
        3) Added shape-related methods to DatabaseService for managing shapes
        4) Added IPC handlers in ProjectService for shapes (save, get by image, get by step)
        5) Extended preload.ts with methods to access shape functions from renderer
        6) Updated StepsTab component to load shapes from database and persist them
        7) Maintained backward compatibility with the existing in-memory store to prevent data loss

This enhancement ensures that when users mark up screenshots with shapes (arrows, rectangles, ellipses), those annotations persist across application restarts. Shapes are now stored both in memory for performance and in the database for persistence.

*   **Date:** 2024-08-14
    *   **Problem:** Shape markup data not persisting when closing/reopening the app or switching tutorials
    *   **Context:** 
        1) When adding markup shapes to images in the Edit Steps section, the shapes would appear correctly but would disappear when the app was restarted or when switching between tutorials
        2) The shapes were being saved to memory (Zustand store) but not properly persisted to the SQLite database
    *   **Difficulty:** Multiple issues were occurring:
        1) The ShapeRepository was not properly converting between database format and store format
        2) The stepId wasn't being consistently included when saving shapes
        3) The clearImageShapeData function wasn't being called at the right time when switching tutorials
        4) No verification was happening to confirm shapes were actually stored in the database
    *   **Status:** Resolved - Implemented the following fixes:
        1) Added detailed logging throughout the shape saving and loading process for better debugging
        2) Updated the shape database repository to include stepId in database queries and verify saves
        3) Modified the loadStepsForTutorial function to properly clear shapes before loading new ones
        4) Fixed the handleSaveMarkup function to ensure stepId is included in all shapes before saving
        5) Enhanced the clearImageShapeData function in the store to provide better logging
        6) Verified the database location at %APPDATA%\OpenScribe\openscribe\openscribe.db
        7) Added verification queries to confirm shapes are properly saved and loaded from the database

This enhancement ensures that when users mark up screenshots with shapes (arrows, rectangles, ellipses), those annotations persist across application restarts. Shapes are now stored both in memory for performance and in the database for persistence.

*   **Date:** 2024-08-15
    *   **Problem:** Shape markup appearing across all steps instead of being step-specific
    *   **Context:** 
        1) When adding markup shapes to a specific step, the shapes were appearing on all steps that shared the same screenshot path
        2) The shapes were being stored in the database with the stepId, but retrieving and displaying shapes had issues
    *   **Difficulty:** Multiple issues needed to be fixed:
        1) The useStepsStore.getShapesForImage method was not properly filtering by stepId when called without it
        2) Several UI components were calling getShapesForImage without providing the stepId parameter
        3) The composite key format in the store (stepId:imagePath) was correct but not all code was using it properly
        4) Missing the stepId parameter in saveShapesForImage calls in error handling paths
    *   **Solution:** 
        1) Updated useStepsStore.getShapesForImage to explicitly require stepId and return empty array if none provided
        2) Fixed all UI components to properly pass stepId when calling getShapesForImage
        3) Added proper error handling for cases where stepId might be missing
        4) Fixed the error fallback path in handleSaveMarkup to include stepId
        5) Updated the PreviewCanvas component to show only shapes for the selected step

    *   **Resolution** Shapes are now correctly associated with specific steps and only appear on the steps they were drawn on.

*   **Date:** 2024-09-07
    *   **Problem:** Shape markup appearing across all steps instead of being step-specific (recurring issue)
    *   **Context:** 
        1) When adding markup shapes to a specific step, the shapes were appearing on all steps instead of being specific to the step where they were drawn
        2) This issue was previously fixed but had recurred due to inconsistent use of stepId in some parts of the codebase
    *   **Difficulty:** Multiple related issues were found:
        1) The ExportTab component was retrieving shapes using only the image path without filtering by stepId
        2) There was an instance of getShapesByImage being called without the stepId parameter 
        3) The openMarkupModal function was being called with potentially undefined screenshotPath
        4) The getShapesForImage function in the store allowed stepId to be optional when it should be required
    *   **Solution:** 
        1) Updated the PreviewCanvas component in ExportTab to properly use stepId when retrieving shapes
        2) Modified useStepsStore.getShapesForImage to make stepId a required parameter
        3) Fixed the error path in handleSaveMarkup to include stepId
        4) Added null check for screenshotPath before calling openMarkupModal
        5) Updated type definitions in preload.d.ts to include stepId parameter for getShapesByImage
        
    *   **Resolution:** Shapes now correctly appear only on the specific steps they were drawn on, resolving the issue of markup appearing across all steps.

*   **Date:** 2024-09-23
    *   **Problem:** Step ID display taking up unnecessary space in the UI and Delete button placement not optimal
    *   **Context:** 
        1) The Step ID was displayed at the bottom of the step edit view but wasn't necessary for users
        2) The Delete button was placed at the bottom of the step, making it less discoverable
    *   **Difficulty:** Simple UI layout adjustment
    *   **Status:** Resolved - Implemented the following improvements:
        1) Removed the Step ID display from the UI completely as it wasn't useful for end users
        2) Moved the Delete button to the top header of the step editor for better discoverability
        3) Maintained the footer section for potential future additions

[2024-08-19] Issue: Markup not appearing on exported step documentation
Problem: When exporting tutorials as PDF or DOCX, the markup annotations (shapes, lines, arrows) 
were not appearing on the exported screenshots despite being visible in the preview.
Root cause: The shape data wasn't being properly mapped between the renderer process and main process.
The shapes were stored with keys in the format `stepId:imagePath` but the export service 
was only looking up shapes by direct imagePath.
Solution:
1. Updated ExportService.ts to explicitly send shape data to main process before export
2. Enhanced the applyShapesToImage method to look for shape data using pattern matching if direct 
   path lookup fails (checking for keys with format `stepId:imagePath`)
3. Added better logging and error handling in the ExportService
4. Fixed the IPC method name discrepancy between preload and renderer
This ensures that markup properly appears in the exported PDF and DOCX files.

*   **Date:** 2025-10-10
    *   **Problem:** Step titles not being saved when clicking off the tab or exporting tutorial
    *   **Context:** 
        1) Users were reporting that when they changed the title of a step and clicked away (or exported), the title reverted to the default
        2) Only step descriptions were being saved properly, titles were being lost
    *   **Difficulty:** Multiple architectural issues:
        1) The database schema doesn't have a dedicated field for step titles, using only 'actionText' which was being used for step descriptions
        2) When saving steps, the title field was updated in the UI store but not saved to the database
        3) When loading steps, there was no mechanism to extract title information from the database
    *   **Status:** Resolved - Implemented the following fixes:
        1) Modified the handleStepUpdate function to save both title and description in the actionText field using a special format: "[TITLE]Title text[DESC]Description text"
        2) Updated the loadStepsForTutorial function to parse this format when loading steps from the database
        3) Added similar formatting in the addStep function for consistency
        4) This provides a backward-compatible solution without requiring database schema changes
